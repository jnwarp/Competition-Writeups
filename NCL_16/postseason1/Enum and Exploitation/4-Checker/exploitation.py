
# this one is fairly easy to find patterns due to xor operation
def loop1(number, debug=True):
	v2, v3 = 0, 0

	for digit in number:
		v3 = ord(digit) ^ v2

		if debug:
			print ord(digit), v2, v3
			
		v2 = v3

	return v3

# this one is a bit tougher to see patterns
# solve this by printing a bunch of info at each iteration
def loop2(number, debug=True):
	v4 = 0
	v5 = 0

	if debug:
		print("{:10}|{:10}|{:10}".format('digit','v4','v5'))

	for digit in number:
		v5 = ord(digit) + v4
		# woops this is wrong (?)
		#			idk haha, need to double-check two's complement stuff
		# v4 = (v5 % 256) | (v4 & 0xFF)
		v4 = (v5 % 256) | (v4 & -256)	# i.e. (v4 & 0x100)  ???

		if debug:
			print("{:10b}|{:10b}|{:10b}".format(ord(digit),v4,v5))

	return v5

# tries both loops and shows result (for brevity in checking answers)
def full(number):
	n1, n2 = loop1(number, False), loop2(number, False)
	print("loop1: {}".format(n1))
	print("loop2: {}".format(n2))

	return ((n1+n2) % 256)


# solved!
solution = '@'*12 + '6'*4


import sys
if __name__ == '__main__':
	full(sys.argv[1])
