//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
// Copyright (c) 2016 Retargetable Decompiler <info@retdec.com>
//

#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

// ------------------- Function Prototypes --------------------

int32_t explode(void);
int32_t get_line(char * str);
char * init(void);
int32_t level_five(char * str);
int32_t level_four(char * str);
int32_t level_one(char * str);
int32_t level_six(int32_t a1);
int32_t level_three(char * str);
int32_t level_two(int32_t a1);
int32_t mystery_func(int32_t a1);
int32_t read_six_numbers(char * str, int32_t * a2);

// --------------------- Global Variables ---------------------

int32_t g1 = 0; // ebp
struct _IO_FILE * g2 = NULL; // 0x804b040
int32_t g3 = 0; // 0x804b048

// ------------------------ Functions -------------------------

// Address range: 0x804860d - 0x8048723
int main(int argc, char ** argv) {
    init();
    printf("Welcome! You're just 6 levels away from winning.\nOne wrong input and... you'll see.\nGo ahead!\n> ");
    int32_t v1;
    int32_t v2 = &v1; // 0x8048633_0
    get_line((char *)&v1);
    level_one((char *)&v1);
    printf("Not too shabby. Let's try something else.\n> ");
    get_line((char *)&v1);
    level_two(v2);
    printf("Okay, okay, I see you are versed in mathematics.\n> ");
    get_line((char *)&v1);
    level_three((char *)&v1);
    printf("You're half way done now!\n> ");
    get_line((char *)&v1);
    level_four((char *)&v1);
    printf("Okay, this is getting a bit out of hand.\n> ");
    get_line((char *)&v1);
    level_five((char *)&v1);
    printf("This is it, last one, do it, do it now!.\n> ");
    get_line((char *)&v1);
    level_six(v2);
    puts("Wow, you did it! Nice! Tell the rest of your team!");
    if (*(int32_t *)20 != *(int32_t *)20) {
        // 0x804871d
        __stack_chk_fail();
        // branch -> 0x8048722
    }
    // 0x8048722
    return 0;
}

// Address range: 0x8048724 - 0x8048775
int32_t get_line(char * str) {
    // 0x8048724
    fgets(str, 100, g2);
    int32_t v1 = (int32_t)str - 1 + strlen(str); // 0x804875d
    char * v2 = (char *)v1;
    unsigned char v3 = *v2; // 0x804875f
    int32_t result = v3; // 0x8048775_2
    if (v3 == 10) {
        // 0x8048766
        *v2 = 0;
        result = v1;
        // branch -> 0x8048774
    }
    // 0x8048774
    return result;
}

// Address range: 0x8048776 - 0x8048799
int32_t level_one(char * str) {
    // 0x8048776
    if (strcmp(str, "The cold never bothered me anyway.") != 0) {
        // 0x8048793
        explode();
        // branch -> 0x8048798
    }
    // 0x8048798
    return 0;
}

// Address range: 0x804879a - 0x80487e9
int32_t level_two(int32_t a1) {
    int32_t v1;
    read_six_numbers((char *)a1, &v1);
    int32_t v2 = 1;
    // branch -> 0x80487bb
    int32_t result; // 0x80487cb
    while (true) {
        int32_t v3 = g1; // 0x80487c7
        result = *(int32_t *)(v3 - 32 + 4 * (v2 - 1)) * (v2 + 2);
        if (result != *(int32_t *)(4 * v2 - 32 + v3)) {
            // 0x80487d9
            explode();
            // branch -> 0x80487de
        }
        int32_t v4 = v2 + 1; // 0x80487de
        if (v4 >= 6) {
            // break -> 0x80487e8
            break;
        }
        v2 = v4;
        // continue -> 0x80487bb
    }
    // 0x80487e8
    return result;
}

// Address range: 0x80487ea - 0x8048877
int32_t level_three(char * str) {
    int32_t v1;
    int32_t v2;
    int32_t v3;
    sscanf(str, "%d %c %d", &v2, &v3, &v1);
    if (v2 > 929) {
        // 0x8048871
        explode();
        // branch -> 0x8048876
        // 0x8048876
        return 1105;
    }
    int32_t v4 = 0x1000000 * v3; // 0x8048826
    if (v4 == 0x6e000000) {
        // 0x8048822
        // branch -> 0x804885a
        // 0x804885a
        if (v1 != 394) {
            // 0x8048866
            // branch -> 0x8048871
        }
        // 0x8048871
        explode();
        // branch -> 0x8048876
        // 0x8048876
        return 1105;
    }
    // 0x804882e
    int32_t v5; // 0x8048844
    if (v4 <= 0x6e000000) {
        // 0x8048833
        if (v4 == 0x65000000) {
            // 0x804884e
            v5 = v1;
            // branch -> 0x804884e
            // 0x804884e
            if (v5 != 1235) {
                // 0x804885a
                if (v5 != 394) {
                    // 0x8048866
                    // branch -> 0x8048871
                }
            }
        }
        // 0x8048871
        explode();
        // branch -> 0x8048876
        // 0x8048876
        return 1105;
    }
    // 0x804883a
    switch (v4 / 0x1000000) {
        case 111: {
            // 0x804883a
            // branch -> 0x8048866
            // 0x8048866
            // branch -> 0x8048871
            break;
        }
        case 119: {
            // 0x8048844
            v5 = v1;
            if (v5 == 1105) {
                // 0x8048876
                return 1105;
            }
            // 0x804884e
            if (v5 != 1235) {
                // 0x804885a
                if (v5 != 394) {
                    // 0x8048866
                    // branch -> 0x8048871
                }
            }
            break;
        }
    }
    // 0x8048871
    explode();
    // branch -> 0x8048876
    // 0x8048876
    return 1105;
}

// Address range: 0x8048878 - 0x80488ad
int32_t level_four(char * str) {
    int32_t v1;
    sscanf(str, "%d", &v1);
    if (mystery_func(v1) != -23) {
        // 0x80488a7
        explode();
        // branch -> 0x80488ac
    }
    // 0x80488ac
    return -23;
}

// Address range: 0x80488ae - 0x804894b
int32_t level_five(char * str) {
    if (strlen(str) != 5) {
        // 0x80488dc
        explode();
        // branch -> 0x8048913
    }
    // branch -> 0x80488ea
    int32_t str2;
    for (int32_t i = 0; i < 5; i++) {
        unsigned char v1 = *(char *)(i + (int32_t)str); // 0x80488f2
        char v2 = *(char *)((int32_t)(v1 % 16) | (int32_t)"vhdjeekbypugimna"); // 0x8048902
        *(char *)(i + (int32_t)&str2) = v2;
        // continue -> 0x80488ea
    }
    // 0x8048919
    if (strcmp((char *)&str2, "hyena") != 0) {
        // 0x8048934
        explode();
        // branch -> 0x8048939
    }
    int32_t result = *(int32_t *)20; // 0x804893d
    if (result != 0) {
        // 0x8048945
        __stack_chk_fail();
        // branch -> 0x804894a
    }
    // 0x804894a
    return result;
}

// Address range: 0x804894c - 0x80489ea
int32_t level_six(int32_t a1) {
    int32_t v1;
    read_six_numbers((char *)a1, &v1);
    int32_t v2 = 0;
    // branch -> 0x8048974
    int32_t v3;
    int32_t v4; // 0x80489d91222
    while (true) {
        int32_t * v5 = (int32_t *)(4 * v2 - 32 + g1); // 0x8048977_0
        int32_t v6; // 0x8048990
        if (*v5 > 6) {
          lab_0x804898b:
            // 0x804898b
            explode();
            // branch -> 0x8048990
        } else {
            // 0x8048980
            if (*v5 <= 0) {
                goto lab_0x804898b;
            }
            // 0x8048990
            v6 = v2 + 1;
            if (v6 >= 6) {
                v3 = 0;
                v4 = -1;
                // break -> 0x80489b6
                break;
            }
            v2 = v6;
            // continue -> 0x8048974
            continue;
        }
        // 0x8048990
        v6 = v2 + 1;
        if (v6 >= 6) {
            v3 = 0;
            v4 = -1;
            // break -> 0x80489b6
            break;
        }
        v2 = v6;
        // continue -> 0x8048974
    }
    int32_t result; // 0x80489d9
    while (true) {
        int32_t * v7 = (int32_t *)(4 * v3 - 32 + g1); // bp+018
        int32_t * v8; // 0x80489c9_0
        if (*(int32_t *)g3 != *v7) {
            int32_t v9 = *(int32_t *)(g3 + 8);
            while (*(int32_t *)v9 != *v7) {
                // 0x80489ad
                v9 += 8;
                // continue -> 0x80489ad
            }
            // 0x80489c6
            v8 = (int32_t *)(v9 + 4);
            if (*v8 >= v4) {
              lab_0x80489d1:
                // 0x80489d1
                explode();
                // branch -> 0x80489d6
            }
          lab_0x80489d6:
            // 0x80489d6
            result = *v8;
            int32_t v10 = v3 + 1; // 0x80489df
            if (v10 >= 6) {
                // break -> 0x80489e9
                break;
            }
            v3 = v10;
            v4 = result;
            // continue -> 0x80489b6
            continue;
        }
        // 0x80489c6
        v8 = (int32_t *)(g3 + 4);
        if (*v8 < v4) {
            goto lab_0x80489d6;
        }
        goto lab_0x80489d1;
    }
    // 0x80489e9
    return result;
}

// Address range: 0x80489eb - 0x8048a24
int32_t mystery_func(int32_t a1) {
    int32_t result = 1;
    if (a1 > 1) {
        int32_t v1 = mystery_func(a1 - 2); // 0x8048a08
        result = mystery_func(a1 - 1) + v1;
        // branch -> 0x8048a1f
    }
    // 0x8048a1f
    return result;
}

// Address range: 0x8048a25 - 0x8048a7f
int32_t read_six_numbers(char * str, int32_t * a2) {
    int32_t v1 = (int32_t)a2;
    int32_t v2;
    g1 = v2;
    return sscanf(str, "%d %d %d %d %d %d", a2, (int32_t *)(v1 + 4), (int32_t *)(v1 + 8), (int32_t *)(v1 + 12), (int32_t *)(v1 + 16), (int32_t *)(v1 + 20));
}

// Address range: 0x8048a80 - 0x8048a9d
int32_t explode(void) {
    int32_t v1;
    g1 = &v1;
    puts("BOOM BOOM!!\nThe bomb exploded. Try again!");
    exit(1);
    // UNREACHABLE
}

// Address range: 0x8048a9e - 0x8048bcf
char * init(void) {
    char * mem = malloc(12); // 0x8048aab
    int32_t v1 = (int32_t)mem; // 0x8048aab_3
    g3 = v1;
    *(int32_t *)mem = 1;
    *(int32_t *)(v1 + 4) = 29;
    char * mem2 = malloc(12); // 0x8048ad5
    int32_t * v2 = (int32_t *)(v1 + 8); // 0x8048adf_0
    *v2 = (int32_t)mem2;
    int32_t v3 = *v2; // 0x8048ae5
    *(int32_t *)v3 = 2;
    *(int32_t *)(v3 + 4) = 724;
    char * mem3 = malloc(12); // 0x8048b05
    int32_t * v4 = (int32_t *)(v3 + 8); // 0x8048b0f_0
    *v4 = (int32_t)mem3;
    int32_t v5 = *v4; // 0x8048b15
    *(int32_t *)v5 = 3;
    *(int32_t *)(v5 + 4) = 989;
    char * mem4 = malloc(12); // 0x8048b35
    int32_t * v6 = (int32_t *)(v5 + 8); // 0x8048b3f_0
    *v6 = (int32_t)mem4;
    int32_t v7 = *v6; // 0x8048b45
    *(int32_t *)v7 = 4;
    *(int32_t *)(v7 + 4) = 1192;
    char * mem5 = malloc(12); // 0x8048b65
    int32_t * v8 = (int32_t *)(v7 + 8); // 0x8048b6f_0
    *v8 = (int32_t)mem5;
    int32_t v9 = *v8; // 0x8048b75
    *(int32_t *)v9 = 5;
    *(int32_t *)(v9 + 4) = 75;
    char * mem6 = malloc(12); // 0x8048b95
    int32_t * v10 = (int32_t *)(v9 + 8); // 0x8048b9f_0
    *v10 = (int32_t)mem6;
    int32_t v11 = *v10; // 0x8048ba5
    *(int32_t *)v11 = 6;
    *(int32_t *)(v11 + 4) = 1104;
    *(int32_t *)(v11 + 8) = 0;
    return (char *)v11;
}

// --------------- Dynamically Linked Functions ---------------

// void __stack_chk_fail(void);
// void exit(int status);
// char * fgets(char * restrict s, int n, FILE * restrict stream);
// void * malloc(size_t size);
// int printf(const char * restrict format, ...);
// int puts(const char * s);
// int sscanf(const char * restrict s, const char * restrict format, ...);
// int strcmp(const char * s1, const char * s2);
// size_t strlen(const char * s);

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (4.8.4)
// Detected functions: 12
// Decompiler release: v2.2.1 (2016-09-07)
// Decompilation date: 2016-12-05 09:33:39
